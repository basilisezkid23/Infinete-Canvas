<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Infinite Canvas — single file</title>
<style>
  :root{
    --bg:#f7f7f9;
    --card:#fff;
    --muted:#666;
    --accent:#111;
  }
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;}
  body{background:linear-gradient(180deg,#f2f6fb 0%,var(--bg) 100%);display:flex;flex-direction:column}
  /* top toolbar */
  .toolbar{
    display:flex;gap:.5rem;padding:.6rem;background:rgba(255,255,255,.8);align-items:center;
    box-shadow:0 1px 6px rgba(0,0,0,.06);backdrop-filter:blur(4px);
  }
  .btn{padding:.45rem .65rem;border-radius:.45rem;background:var(--card);border:1px solid rgba(0,0,0,.06);cursor:pointer}
  .btn:active{transform:translateY(1px)}
  .muted{color:var(--muted);font-size:.9rem;margin-left:auto}
  /* viewport */
  .viewport{flex:1;position:relative;overflow:hidden;}
  .stage-wrap{width:100%;height:100%;touch-action:none;cursor:grab;background:
    linear-gradient(90deg, rgba(0,0,0,0.02) 1px, transparent 1px),
    linear-gradient(180deg, rgba(0,0,0,0.02) 1px, transparent 1px);
    background-size: 40px 40px, 40px 40px;
    display:flex;align-items:flex-start;justify-content:flex-start;
  }
  .stage {
    transform-origin: 0 0;
    position: absolute;
    left:0;top:0;
    min-width:3000px;min-height:3000px; /* gives you a huge space to drop on */
  }
  .node{
    position:absolute;background:var(--card);border-radius:10px;padding:6px;border:1px solid rgba(0,0,0,.06);
    box-shadow: 0 6px 18px rgba(15,15,15,0.06);display:inline-block;
    max-width:900px;overflow:hidden;
  }
  .node .handle{position:absolute;right:6px;top:6px;font-size:12px;cursor:grab;opacity:.8}
  .node img, .node video, .node iframe{display:block;max-width:720px;max-height:540px;width:auto;height:auto;border-radius:6px}
  .note{min-width:160px;min-height:80px;padding:10px;outline:none}
  .link-preview{padding:8px;max-width:420px}
  .controls{display:flex;gap:.4rem}
  .small{font-size:.85rem;padding:.2rem .45rem}
  .hint{font-size:.85rem;color:var(--muted);padding-left:.6rem}
  /* selection highlight */
  .node.selected{box-shadow:0 8px 30px rgba(15,15,15,0.12);border-color:#8aa7ff}
  /* export notice */
  .notice{position:absolute;left:8px;bottom:8px;background:rgba(255,255,255,.95);padding:.45rem .6rem;border-radius:.45rem;border:1px solid rgba(0,0,0,.06);font-size:.85rem}
</style>
</head>
<body>
  <div class="toolbar">
    <button id="addText" class="btn">+ Text</button>
    <button id="zoomIn" class="btn small">Zoom +</button>
    <button id="zoomOut" class="btn small">Zoom −</button>
    <button id="resetView" class="btn small">Reset</button>
    <button id="exportHtml" class="btn small">Export HTML</button>
    <div class="hint">Drop images / videos / .txt files or paste a URL onto the canvas</div>
    <div class="muted">Tip: middle-click or space+drag to pan</div>
  </div>

  <div class="viewport">
    <div id="stageWrap" class="stage-wrap">
      <div id="stage" class="stage"></div>
    </div>
    <div class="notice">Scale: <span id="scaleLabel">100%</span></div>
  </div>

<script>
/* ---- Simple infinite-like canvas with pan/zoom and drop handling ----
   - Drop file types: images (png/jpg/svg), video (mp4/webm), text files (.txt).
   - Drop plain text that looks like a URL -> create iframe (if blocked falls back to link).
   - Elements are draggable inside stage; double-click to remove.
   - Export will serialize stage children as a downloadable HTML file.
   Caveats: many external sites block iframes (X-Frame-Options); app falls back to link preview.
*/

const stageWrap = document.getElementById('stageWrap');
const stage = document.getElementById('stage');
const scaleLabel = document.getElementById('scaleLabel');

let scale = 1;
let pan = {x: 0, y: 0};
let isPanning = false;
let panStart = {x:0,y:0};
let wrapStart = {x:0,y:0};

// apply transform
function updateTransform(){
  stage.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${scale})`;
  scaleLabel.textContent = Math.round(scale*100) + '%';
}
updateTransform();

// Panning controls: space+drag or middle mouse or two-finger on touchpad
stageWrap.addEventListener('mousedown', (e)=>{
  if (e.button === 1 || e.shiftKey || e.spaceKey) {
    isPanning = true;
    stageWrap.style.cursor = 'grabbing';
    panStart = {x: e.clientX, y: e.clientY};
    wrapStart = {x: pan.x, y: pan.y};
    e.preventDefault();
  }
});
window.addEventListener('mouseup', ()=>{ isPanning = false; stageWrap.style.cursor = 'grab'; });
window.addEventListener('mousemove', (e)=>{
  if (isPanning) {
    const dx = (e.clientX - panStart.x);
    const dy = (e.clientY - panStart.y);
    pan.x = wrapStart.x + dx;
    pan.y = wrapStart.y + dy;
    updateTransform();
  }
});

// wheel to zoom (ctrl+wheel for zoom, otherwise scroll stage)
stageWrap.addEventListener('wheel', (e)=>{
  if (e.ctrlKey || e.metaKey) {
    const delta = -e.deltaY * 0.0015;
    const prev = scale;
    scale = Math.min(3, Math.max(0.2, scale * (1 + delta)));
    // zoom to mouse position:
    const rect = stageWrap.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    // adjust pan so content under mouse stays under mouse
    pan.x = mx - (mx - pan.x) * (scale / prev);
    pan.y = my - (my - pan.y) * (scale / prev);
    updateTransform();
    e.preventDefault();
  }
}, {passive:false});

// toolbar
document.getElementById('zoomIn').addEventListener('click', ()=>{
  scale = Math.min(3, scale * 1.12);
  updateTransform();
});
document.getElementById('zoomOut').addEventListener('click', ()=>{
  scale = Math.max(0.2, scale / 1.12);
  updateTransform();
});
document.getElementById('resetView').addEventListener('click', ()=>{
  scale = 1; pan = {x:0,y:0}; updateTransform();
});
document.getElementById('addText').addEventListener('click', ()=>{
  createTextNode(200, 200, 'Double-click to edit text\nDrag to move me');
});
document.getElementById('exportHtml').addEventListener('click', exportAsHtml);

// Drag & drop handling
['dragenter','dragover'].forEach(ev => {
  window.addEventListener(ev, (e)=>{ e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
});
window.addEventListener('drop', async (e)=>{
  e.preventDefault();
  const x = (e.clientX - stageWrap.getBoundingClientRect().left - pan.x) / scale;
  const y = (e.clientY - stageWrap.getBoundingClientRect().top - pan.y) / scale;

  // If there are files:
  if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length){
    for (const file of e.dataTransfer.files) {
      const type = file.type;
      if (type.startsWith('image/')) {
        const url = URL.createObjectURL(file);
        createImageNode(x, y, url, file.name);
      } else if (type.startsWith('video/')) {
        const url = URL.createObjectURL(file);
        createVideoNode(x, y, url, file.name);
      } else if (type === 'text/plain' || file.name.endsWith('.txt')) {
        const text = await file.text();
        createTextNode(x, y, text);
      } else {
        // fallback: create a download link
        const url = URL.createObjectURL(file);
        createLinkNode(x, y, url, file.name);
      }
      // offset next item a bit
      x += 20; y += 20;
    }
    return;
  }

  // If plain text or url pasted/dropped
  const plain = e.dataTransfer.getData('text/plain') || e.dataTransfer.getData('text/uri-list');
  if (plain && plain.trim()){
    handleDroppedText(x, y, plain.trim());
  }
});

// also handle paste (Ctrl+V) for URLs or images from clipboard (images require clipboard.read)
window.addEventListener('paste', async (e)=>{
  const items = e.clipboardData && e.clipboardData.items;
  if (!items) return;
  const rect = stageWrap.getBoundingClientRect();
  const x = (rect.width/2 - pan.x) / scale;
  const y = (rect.height/2 - pan.y) / scale;
  for (const item of items){
    if (item.type.startsWith('image/')) {
      const blob = item.getAsFile();
      const url = URL.createObjectURL(blob);
      createImageNode(x, y, url, 'clipboard-image');
    } else if (item.type === 'text/plain') {
      const text = e.clipboardData.getData('text/plain');
      handleDroppedText(x,y,text);
    }
  }
});

// Helpers to create nodes
function createNodeAt(x,y,el){
  const node = document.createElement('div');
  node.className = 'node';
  node.style.left = (x|0) + 'px';
  node.style.top = (y|0) + 'px';
  node.appendChild(el);
  // small handle
  const h = document.createElement('div'); h.className='handle'; h.textContent='☰';
  node.appendChild(h);
  makeDraggable(node);
  stage.appendChild(node);
  return node;
}

function createImageNode(x,y,src,alt='image'){
  const img = document.createElement('img');
  img.src = src; img.alt = alt;
  img.loading = 'lazy';
  const node = createNodeAt(x,y,img);
  return node;
}

function createVideoNode(x,y,src,name='video'){
  const vid = document.createElement('video');
  vid.src = src; vid.controls = true; vid.preload = 'metadata';
  vid.style.maxWidth='720px';
  const node = createNodeAt(x,y,vid);
  return node;
}

function createTextNode(x,y,txt=''){
  const el = document.createElement('div');
  el.className='note';
  el.contentEditable = true;
  el.spellcheck = false;
  el.innerText = txt;
  el.style.whiteSpace = 'pre-wrap';
  const node = createNodeAt(x,y,el);
  return node;
}

function createLinkNode(x,y,url,title){
  // try iframe embedding, but may fail due to X-Frame-Options — handle fallback
  const container = document.createElement('div');
  container.className = 'link-preview';
  const iframe = document.createElement('iframe');
  iframe.src = url;
  iframe.width = '420';
  iframe.height = '260';
  iframe.style.border = '1px solid rgba(0,0,0,.06)';
  iframe.onload = ()=>{ /* fine */ };
  iframe.onerror = ()=>{ /* fallback handled via message below */ };
  // if blocked, show fallback
  const link = document.createElement('a');
  link.href = url; link.target='_blank';
  link.textContent = title || url;
  link.style.display='block';
  link.style.wordBreak='break-all';
  // attempt to embed, but if loading blocked, we will show link only
  container.appendChild(iframe);
  container.appendChild(document.createElement('hr'));
  container.appendChild(link);
  const node = createNodeAt(x,y,container);
  // test whether embedding works after a short time
  setTimeout(()=>{
    try {
      const doc = iframe.contentDocument;
      // browsers block access if cross-origin; so we can't rely on reading doc
    } catch (err) {
      // nothing to do — fallback link is there anyway
    }
  },800);
  return node;
}

async function handleDroppedText(x,y,text){
  // If it's a single URL, embed
  const urlmatch = text.match(/https?:\/\/\S+/);
  if (urlmatch && urlmatch[0] === text.trim()){
    // create iframe, with fallback to link
    createLinkNode(x,y,text.trim(), text.trim());
  } else {
    // otherwise, add as editable note
    createTextNode(x,y,text);
  }
}

/* Make node draggable within stage */
function makeDraggable(node){
  let dragging=false, start={x:0,y:0}, nodeStart={x:0,y:0};
  const handle = node.querySelector('.handle') || node;
  handle.addEventListener('mousedown', (ev)=>{
    // left click drag on handle
    if (ev.button !== 0) return;
    dragging = true;
    start = {x: ev.clientX, y: ev.clientY};
    nodeStart = {x: parseInt(node.style.left||0), y: parseInt(node.style.top||0)};
    node.classList.add('selected');
    ev.stopPropagation(); ev.preventDefault();
  });
  window.addEventListener('mousemove', (ev)=>{
    if (!dragging) return;
    const dx = (ev.clientX - start.x) / scale;
    const dy = (ev.clientY - start.y) / scale;
    node.style.left = (nodeStart.x + dx) + 'px';
    node.style.top = (nodeStart.y + dy) + 'px';
  });
  window.addEventListener('mouseup', ()=>{ dragging=false; node.classList.remove('selected'); });

  // double-click to remove
  node.addEventListener('dblclick', (e)=>{
    e.stopPropagation();
    if (confirm('Delete this item?')) node.remove();
  });
}

/* Export HTML: we serialize the stage inner HTML inside a minimal wrapper so you can share a single file.
   Note: embedded object URLs (from local files) won't work in exported HTML. For persistent sharing embed base64.
   For simplicity we export with data URLs for images/videos if possible (small).
*/
async function exportAsHtml(){
  // convert local object URLs to data URLs where possible
  const clone = stage.cloneNode(true);
  // find img/video srcs that are object URLs and convert:
  const imgs = clone.querySelectorAll('img');
  for (const img of imgs){
    if (img.src.startsWith('blob:') || img.src.startsWith('filesystem:')) {
      try {
        const data = await fetch(img.src).then(r=>r.blob());
        const dataUrl = await blobToDataURL(data);
        img.src = dataUrl;
      } catch(e){}
    }
  }
  const vids = clone.querySelectorAll('video');
  for (const v of vids){
    if (v.src && (v.src.startsWith('blob:')||v.src.startsWith('filesystem:'))){
      try {
        const data = await fetch(v.src).then(r=>r.blob());
        const dataUrl = await blobToDataURL(data);
        v.src = dataUrl;
      } catch(e){}
    }
  }
  // Remove JS event handlers by serializing only attributes and innerHTML. We'll export a small runtime wrapper
  const exported = `
<!doctype html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>Exported Canvas</title>
<style>
body{margin:0;font-family:system-ui;background:#f7f7f9}
.wrapper{position:relative;padding:20px}
.node{position:absolute;background:#fff;border:1px solid rgba(0,0,0,.06);border-radius:8px;padding:6px}
</style>
</head><body>
<div class="wrapper">
<p>Exported canvas. Open in browser. (This is a static preview; to keep interactivity you'd export the whole app —ask me for a persistent-export mode.)</p>
<div id="stage">${clone.innerHTML}</div>
</div>
</body></html>
  `.trim();
  const blob = new Blob([exported], {type:'text/html'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'canvas-export.html';
  a.click();
  URL.revokeObjectURL(url);
}

function blobToDataURL(blob){
  return new Promise((resolve,reject)=>{
    const r = new FileReader();
    r.onload = ()=>resolve(r.result);
    r.onerror = reject;
    r.readAsDataURL(blob);
  });
}

/* Small UX: double-click stage to add text at cursor */
stageWrap.addEventListener('dblclick', (e)=>{
  const rect = stageWrap.getBoundingClientRect();
  const x = (e.clientX - rect.left - pan.x) / scale;
  const y = (e.clientY - rect.top - pan.y) / scale;
  createTextNode(x,y,'');
});

// quick keyboard: Delete to remove selected nodes
window.addEventListener('keydown', (e)=>{
  if (e.key === 'Delete' || e.key === 'Backspace'){
    const selected = stage.querySelectorAll('.node.selected');
    if (selected.length){
      selected.forEach(n=>n.remove());
    }
  }
});

// small: allow clicking nodes to select/deselect
stage.addEventListener('click', (e)=>{
  const node = e.target.closest('.node');
  stage.querySelectorAll('.node').forEach(n=>n.classList.remove('selected'));
  if (node) node.classList.add('selected');
});

// Make stage large and centered initially
stage.style.left = '200px';
stage.style.top = '200px';
</script>
</body>
</html>
